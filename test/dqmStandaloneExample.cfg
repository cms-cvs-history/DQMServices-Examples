process test={
    
    untracked PSet maxEvents = {untracked int32 input = 2000}
    source = EmptySource {}
    
    # back-end interface service
    service = DaqMonitorROOTBackEnd{}
    
    # MonitorDaemon configuration
    # enable this if you would like to feed info down to a collector
    service = MonitorDaemon {
    # if true, will automatically start DQM thread in background
         untracked bool AutoInstantiate=true
    # if >=0, upon a connection problem, the source will automatically 
    # attempt to reconnect with a time delay (secs) specified here 
    # (default: 5)
         untracked int32 reconnect_delay = 5
    # collector hostname; examples: localhost(default),lxcmse2.cern.ch, etc
         untracked string DestinationAddress = "localhost"
    # port for communicating with collector (default: 9090)
         untracked int32 SendPort = 9090
    # monitoring period in ms (i.e. how often monitoring elements 
    # are shipped to the collector; default: 1000)
         untracked int32 UpdateDelay = 1000
    # maximum # of reconnection attempts upon connection problems (default: 10)
         untracked int32 maxAttempts2Reconnect   = 10
    # name of DQM source (default: DQMSource)
         untracked string NameAsSource = "Example"
    }
    
    # send source _AND_ client histograms out to collector every 5000 events
    service = DQMShipMonitoring{
	// event-period for shipping monitoring to collector (default: 25)
	// untracked uint32 period = 5000
    }
    
    # DQM Source program 
    # code in DQMServices/Daemon/src/DQMSourceExample.cc
    module dqmSource = DQMSourceExample{
	untracked string folderRoot = ""
    }

    # run the quality tests as defined in QualityTests.xml
    module qTester = QualityTester {
	untracked int32 QualityTestPrescaler = 5000
    }

    # DQM Client program
    # code in DQMServices/Examples/src/DQMExampleClient.cc
    # notes:
    # * the prescale is a temporary kludge to avoid call of client on each event
    #   in the next version the EDAnalyzer transition endLuminosityBlock 
    #   should be used
    # * the client performs a fit on h4 every 5000 events
    module dqmClient = DQMClientExample {
        # prepend directory name (default is none)
	untracked string folderRoot = ""
	
	untracked int32 diagnosticPrescale = 5000
	# FIXME steering running on events, ls or collector updates
	# run every so many events (default 1)
	#untracked int32 PrescaleEvt = 1
	# run every so many luminosity blocks (default -1)
	# if >0 this module acts on endluminosityblock
	#                         and NOT on events
	#untracked int32 PrescaleLS = 5000	
	# alternatively run on updates from Collector
	# FIXME to be implemented
	# untracked int32 ....

	# name of output file (dumps out all ME into file) 
        untracked string outputFile = "DQM_example.root" 
    }

    # output into logfiles (verbose)
    service = MessageLogger {
	untracked vstring destinations = { 
	    "detailedInfo" , "critical" , "cout"
	}
	untracked vstring debugModules = { "*" }
	untracked PSet critical     = { untracked string threshold = "ERROR"   }
	untracked PSet detailedInfo = { untracked string threshold = "INFO"    } 
	untracked PSet cout = {
	    untracked string threshold = "WARNING"
	    untracked bool noLineBreaks = true
	    untracked PSet WARNING = {untracked int32 limit = 0 }
	}
    }	
    
    path p ={dqmSource & qTester & dqmClient}

} 
